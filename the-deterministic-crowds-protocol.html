<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">

    

    

    <title>The Deterministic Crowds Protocol | 程序代写</title>
    <meta name="author" content="frank">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="代写，学生代写，assignment代写，留学生代写">
    <meta name="description" content="代写完成–Java 算法: 匿名通信算法Network NodesFollowing is a description adapted from Rass and Wigoutschnigg [2016]. For the purposes of sending a message, there are three kinds of nodes: the initiator, intermediate forwarding nodes, and the receiver. The N...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    

    <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">程序代写</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">案例</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">历史</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://chengxudaixie.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Network-Nodes"><span class="toc-number">1.</span> <span class="toc-text">Network Nodes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Assignment-Code-Structure"><span class="toc-number">2.</span> <span class="toc-text">Assignment Code Structure</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pass-Level"><span class="toc-number">3.</span> <span class="toc-text">Pass Level</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Credit-Level"><span class="toc-number">4.</span> <span class="toc-text">Credit Level</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#High-Distinction-Level"><span class="toc-number">5.</span> <span class="toc-text">(High) Distinction Level</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            The Deterministic Crowds Protocol
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://chengxudaixie.github.io/the-deterministic-crowds-protocol.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-03-18T07:39:00.000Z" itemprop="datePublished">2019-03-18</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JAVA/">JAVA</a>, <a class="article-tag-link" href="/tags/算法/">算法</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <hr>
<p>代写完成–Java 算法: 匿名通信算法</p>
<hr>
<h5 id="Network-Nodes"><a href="#Network-Nodes" class="headerlink" title="Network Nodes"></a>Network Nodes</h5><p>Following is a description adapted from Rass and Wigoutschnigg [2016]. For the purposes of sending a message, there are three kinds of nodes: the initiator, intermediate forwarding nodes, and the receiver. The N nodes of a network will be identiﬁed by integers <code>0, 1, 2, 3 . . . N − 1</code>. </p>
<p>The protocol is, however, still vulnerable to attack by a local eavesdropper (an attacker that can observe all incoming and outgoing messages for any proper subset of the nodes) or an attack known as the predecessor attack.</p>
<a id="more"></a>
<p>Initiator We will call the initiating node $v_0$ . There will be a function $f : N → N$, taking a non-negative integer and producing non-negative integer, that a node will use to decide which node it will send a message to. (Notationally, $f^{−1}$ will be the inverse of this function.)</p>
<p>To transmit a message m to a receiver v, $v_0$ ﬁrst chooses a path length n and calls $v_n := v$ the receiver. It then goes on to choose a value $r_n ≡ v_n  mod  N$, and backward iterates $r_{n−1} = f^{−1} (r_n)$ until it reaches a value $r_1$ . The ﬁrst node to transmit the payload to (where the payload consists of the message m, value r and function f) is thus $v_1 = r_1 mod N$, and the initiator acts just as if it would have if it had computed $r_1$ from the data being sent from elsewhere to $v_0$ .</p>
<p>Question: If there is such a function $f^{−1}$ , how can the protocol prevent any node from tracking the message back? The solution is for f to be a trapdoor function, one whose inverse can only (easily) be calculated by using a trapdoor secret. §2.2 explains these and gives an example of how it is applied here.</p>
<p>Forwarding Node Forwarding node $v_i$ , upon receiving the message m, along with a value $r_i$ and a function f, ﬁrst checks if it is the designated receiver. As it is not, it computes $r_{i+1} = f(r_i)$ and thence the next hop as $v_{i+1} = r_{i+1} mod N$, and sends the message m together with $r_{i+1}$ and f to $v_{i+1}$ .</p>
<p>Receiver Node $v_n$ similarly checks if it is the designated receiver. As it is, the process stops.</p>
<p>2.2 Trapdoor Functions</p>
<p>An Example of a Trapdoor Function Trapdoor functions are used widely in cryptography. The kind of function we’ll be using comes from RSA encryption. 5 There are three values that we’ll be using to deﬁne our function f and its inverse $f^{−1}$ ; we’ll call these e, d and K. e and K will be used to deﬁne f, which will be public; d will be the trapdoor secret.</p>
<p>Our public function will be</p>
<p>$$f(x) = x^e mod K  (1)$$</p>
<p>and our inverting function will be</p>
<p>$$g(x) = x^d mod K (2)$$</p>
<p>There is a process (in cryptography, a key generation algorithm) to ﬁnd values of e, d, K such that $f(g(x)) = x$, i.e. $g(x) = f^{−1} (x)$.</p>
<p>Consider e = 3, d = 7, K = 33. Then, $f(30) = 30^3 mod 33 = 6$. To compute the inverse, $f^{−1} (6) = g(6) = 6^7 mod 33 = 30$. This inverse can only (easily) be computed if d is known.</p>
<p>Applying a Trapdoor to Deterministic Crowds Consider a network (crowd) with nodes 0 . . . 19. Let the message initiator be node $v_0 = 1$. $v_0$ decides on a path length of n = 3 (i.e. via two intermediate forwarding nodes) to send its message to receiver node $v = v_3 = 6$. It makes the following calculations:</p>
<p>$1. r_3 = 6.$</p>
<p>$2. r_2 = f^{−1} (6) = 6^7 mod 33 = 30.$</p>
<p>This corresponds to node $v_2 = r_2 mod N = 30 mod 20 = 10$.</p>
<p>$3. r_1 = f^{−1} (30) = 30^7 mod 33 = 24.$</p>
<p>This corresponds to node $v_1 = r_1 mod N = 24 mod 20 = 4$.</p>
<p>So the node that $v_0$ forwards the message to, along with the value $r_1 = 24$ and function f (but not $f^{−1}$ or the value d that would allow $f^{−1}$ to be calculated), is node 4.The full path will be 1 → 4 → 10 → 6.</p>
<h5 id="Assignment-Code-Structure"><a href="#Assignment-Code-Structure" class="headerlink" title="Assignment Code Structure"></a>Assignment Code Structure</h5><p>You will be working with a Java project that has 4 classes:</p>
<ul>
<li><p>NodeTransitionFunction: This instantiates the functions f(·) and g(·) from Equations (1) and (2) respectively.</p>
</li>
<li><p>Node: This represents a node in the network; it is where the core functionality of the assignment is. Nodes receive messages, determine the next one to forward them to, and carry out the forwarding, among other functions. A node will have an integer ID 0 . . . N − 1, where N is the number of nodes a particular network.</p>
</li>
<li><p>Network: This represents a network of nodes. The key component of the network is a lookup table that is accessible to all nodes, so that nodes can look up properties of other nodes. The table has the form<br><code>Map&lt;Integer,Node&gt; lookup;</code><br>It also contains functions that will be provided for reading network speciﬁcations and messages from ﬁles.</p>
</li>
<li><p>MessageTrackCheck: This represents an encoded trail of which nodes were visited in the process of passing messages. (It is mostly just used in the JUnit tests.)</p>
</li>
</ul>
<p>For your tasks, you’ll be adding attributes and methods to existing classes given in the code bundle accompanying these specs. Where it’s given, you should use exactly the method stub provided for implementing your tasks. Don’t change the names or the parameters or exception handling. You can add more functions if you like.</p>
<h5 id="Pass-Level"><a href="#Pass-Level" class="headerlink" title="Pass Level"></a>Pass Level</h5><p>To achieve at least a Pass (≥ 50%) for the assignment, you should do all of the following.</p>
<p>There will be some sample input ﬁles to be used in the JUnit tests in the code bundle. The sample input nodedef1.in consists of 20 nodes, each with associated trapdoor function parameters e = 3, d = 7, K = 33. Obviously in a real network nodes would have diﬀerent parameter values, and in later input ﬁles they will; it just happens that this triple is the smallest one that works for this kind of trapdoor function, and so the easiest to handle numerically when getting started.</p>
<p>There will be no public Node method to ﬁnd out which node sent a message to the current node. (If there was, there would be no anonymity. However, we will change this slightly for corrupt nodes in the Distinction level tasks.) On the other hand, we want some way of recording which nodes were visited.</p>
<p>The MessageTrackCheck class acts a like a parity check, and works as follows. A MessageTrackCheck instance t will sum the IDs of each node that is involved in passing a message, including the initiator and receiver; it will also add a speciﬁed oﬀset. It will then internally calculate the sum mod 26, and make available the corresponding check character from the lower-case alphabet a . . . z, assuming they are indexed by the values 0 . . . 25 respectively.</p>
<p>So if a message track check has an oﬀset of 3, and a message is passed along a path of nodes 1 → 4 → 10 → 6, the check character would be the character corresponding to (3 + 1 + 4 + 10 + 6) mod 26 = 24, which is y.</p>
<p>Write the following methods for class MessageTrackCheck.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">MessageTrackCheck</span><span class="token punctuation">(</span>Integer offset<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// CONSTRUCTOR: Argument is offset to initialise the running sum </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Integer n<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Adds n to the running sum </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns the character that corresponds to the running sum mod 26; </span>
    <span class="token comment" spellcheck="true">// 0..25 correspond to a..z </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>Integer offset<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Re-initialises the running sum to the given offset </span>
<span class="token punctuation">}</span></code></pre>
<p>Write the following methods for the NodeTransitionFunction class.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">NodeTransitionFunction</span><span class="token punctuation">(</span>Integer exp<span class="token punctuation">,</span> Integer KVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// CONSTUCTOR: Sets the class to calculate f(x) = (x ^ exp) mod KVal </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Integer <span class="token function">apply</span><span class="token punctuation">(</span>Integer val<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Implements f(val) </span>
<span class="token punctuation">}</span>
</code></pre>
<p>Note that if you implement apply() in a straightforward way, you will almost certainly exceed Java’s Integer.MAX_VALUE: try it for yourself with an instance of NodeTransitionFunction instantiated with values 3 and 33, comparing it against the value obtained from e.g. a spreadsheet.</p>
<p>Instead, there is a useful identity that lets you make the calculation without this risk:</p>
<p>$$(ab) mod p = ((a mod p)(b mod p)) mod p$$</p>
<p>Implement apply() using this identity. </p>
<p>Implement a constructor for class Node with the following signature:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Integer n<span class="token punctuation">,</span> Integer e<span class="token punctuation">,</span> Integer d<span class="token punctuation">,</span> Integer K<span class="token punctuation">,</span> Boolean encrypt<span class="token punctuation">,</span> Boolean useBI<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Node<span class="token operator">></span> m<span class="token punctuation">,</span> MessageTrackCheck t<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// CONSTUCTOR:</span>
    <span class="token comment" spellcheck="true">// n is node ID, </span>
    <span class="token comment" spellcheck="true">// e is the exponent for the function f() </span>
    <span class="token comment" spellcheck="true">// d is the exponent for the function g() </span>
    <span class="token comment" spellcheck="true">// K is the divisor in f() and g() </span>
    <span class="token comment" spellcheck="true">// encrypt is true if messages are encrypted, false otherwise </span>
    <span class="token comment" spellcheck="true">// useBI is true if BigInteger should be used for NodeTransitionFunction, false otherwise </span>
    <span class="token comment" spellcheck="true">// m is a non-null map of node IDs to node objects </span>
    <span class="token comment" spellcheck="true">// t is an instance of MessageTrackCheck </span>
<span class="token punctuation">}</span></code></pre>
<p>For the Pass level, encrypt and useBI will be set to false. The parameters e, d and K here correspond to the e, d, K from §2.2.</p>
<p>This task and those below all involve adding to class Node.</p>
<p>For the Pass level, when a message is passed through the network it will have appended to the end a 3-character string that indicates the destination; we will call this combination of the original message and destination the augmented message. A node will therefore know that it is the destination for a message from the ﬁnal three characters of the augmented message. An augmented message that has the value hello006 is thus destined for node 6.</p>
<p>Implement the following method in class Node:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Boolean <span class="token function">isDestinationNode</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an augmented message (i.e. containing 3 characters at the end </span>
    <span class="token comment" spellcheck="true">// indicating destination node) </span>
    <span class="token comment" spellcheck="true">// POST: Returns true if this is the destination node, false otherwise </span>
    <span class="token comment" spellcheck="true">// E.g. For node 6, will return true for "hello006" </span>
<span class="token punctuation">}</span></code></pre>
<p>There are several getter methods for class Node:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Integer <span class="token function">getID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns node ID </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Integer <span class="token function">getE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns value of e in this node’s function f() </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Integer <span class="token function">getK</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns value of K in this node’s function f() </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Boolean <span class="token function">transmittedMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns true if this node has transmitted a message, false otherwise </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> String <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns the current received (non-augmented) message, null if no received message </span>
<span class="token punctuation">}</span></code></pre>
<p>A node will have its own NodeTransitionFunction that corresponds to function f(·) as deﬁned by its own parameters e, K.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> NodeTransitionFunction <span class="token function">createForwardNodeTransitionFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Creates a NodeTransitionFunction using this node’s public function f() </span>
    <span class="token comment" spellcheck="true">// with parameters e, K </span>
<span class="token punctuation">}</span></code></pre>
<p>All nodes have the core functionality of receiving and sending messages. For a node at step i in a path of length n, in sending a message it passes along the payload consisting of the (augmented) message, the value r i , and the node transition function representing a particular f(·) that the next node will use. In our example from §2.2, for the node 1 at the ﬁrst step in the path, it will be sending to node 4, the value of r is 24, and the node transition function is f(·) with e = 3, K = 33.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsgToNode</span><span class="token punctuation">(</span>Node n<span class="token punctuation">,</span> String msg<span class="token punctuation">,</span> Integer r<span class="token punctuation">,</span> NodeTransitionFunction f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: n is a non-null node, </span>
    <span class="token comment" spellcheck="true">// msg is an (augmented) message, </span>
    <span class="token comment" spellcheck="true">// r is the current value of r from the forward transition function.</span>
    <span class="token comment" spellcheck="true">// f is the forward transition function </span>
    <span class="token comment" spellcheck="true">// POST: invokes receiveMsgFromNode on node n </span>
<span class="token punctuation">}</span></code></pre>
<p>The following method speciﬁes what happens when a node receives a message. Continuing the example, when node 4 receives the message from node 1, say the augmented message is hello006: node 4 is then not the destination. So it takes the value r = 24 and calculates the next node to forward the message to, f(24).</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsgFromNode</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Integer id<span class="token punctuation">,</span> Integer r<span class="token punctuation">,</span> NodeTransitionFunction f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an augmented message, </span>
    <span class="token comment" spellcheck="true">// id is the ID of the sending node, </span>
    <span class="token comment" spellcheck="true">// r is the current value of r from the forward transition function, </span>
    <span class="token comment" spellcheck="true">// f is the forward transition function </span>
    <span class="token comment" spellcheck="true">// POST: If this is the destination node, stop; </span>
    <span class="token comment" spellcheck="true">// otherwise, send the message onwards.</span>
    <span class="token comment" spellcheck="true">// Add ID of current (receiving) node to local MessageTrackCheck </span>
<span class="token punctuation">}</span></code></pre>
<p>An initiator has some additional functionality. First, there is a method to construct an augmented message from the original message:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">addDestIDToMsg</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Integer v<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is a message, v is a node ID </span>
    <span class="token comment" spellcheck="true">// POST: Returns a string that concatenates v as a 3-character string to the end of msg. </span>
    <span class="token comment" spellcheck="true">// E.g. for msg="hello", v=6, returns "hello006" </span>
<span class="token punctuation">}</span></code></pre>
<p>Then, it has to calculate the value r 1 to determine which the ﬁrst node is to send the message to, as described in §2.2.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Integer <span class="token function">firstRForInitiatingMessage</span><span class="token punctuation">(</span>Integer k<span class="token punctuation">,</span> Integer v<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: v is destination node ID, k is number of steps </span>
    <span class="token comment" spellcheck="true">// POST: Uses the trapdoor function inverse, applied to destination node v with number of steps k, </span>
    <span class="token comment" spellcheck="true">// to calculate the node path; </span>
    <span class="token comment" spellcheck="true">// returns value of r that determines first step on node path </span>
<span class="token punctuation">}</span></code></pre>
<p>Then, it has to initiate the sending of the message; this involves creating the function f(·) using its own parameters e, K that can be passed along to later nodes in the path.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initiateMessage</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Integer k<span class="token punctuation">,</span> Integer v<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an original message, v is destination node ID, k is number of steps </span>
    <span class="token comment" spellcheck="true">// POST: Adds destination ID to msg; </span>
    <span class="token comment" spellcheck="true">// sends augmented msg to the next node, as determined by firstRForInitiatingMessage(k, v), </span>
    <span class="token comment" spellcheck="true">// along with new forward transition function </span>
<span class="token punctuation">}</span></code></pre>
<h5 id="Credit-Level"><a href="#Credit-Level" class="headerlink" title="Credit Level"></a>Credit Level</h5><p>To achieve at least a Credit (≥ 65%) for the assignment, you should do the following. completed all the Pass-level tasks.</p>
<p>You should also have </p>
<p>For Credit-level tasks and above, it will be up to you to discover how some more advanced Java features work. It will be OK to ask questions, but you’ll be expected to read Java documentation yourself ﬁrst.</p>
<p>In the Credit-level tasks, you’ll be using Java’s BigInteger 9 for calculations of f(·) and g(·). This class has been speciﬁcally designed for dealing with problems like the Integer.MAX_VALUE one noted in the Pass-level tasks.</p>
<p>In class NodeTransitionFunction, add a new method apply() that takes its argument as a BigInteger rather than an Integer.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> BigInteger <span class="token function">apply</span><span class="token punctuation">(</span>BigInteger val<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Implements f(val), with val as a BigInteger </span>
<span class="token punctuation">}</span></code></pre>
<p>You can, and should, still keep your earlier apply() method. From Java’s point of view, the type signatures of these methods are diﬀerent, and it will know which one to invoke by the argument.</p>
<p>Add the following methods to class Node that duplicate several methods from the Pass-level tasks but that use BigInteger rather than Integer.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsgToNode</span><span class="token punctuation">(</span>Node n<span class="token punctuation">,</span> String msg<span class="token punctuation">,</span> BigInteger r<span class="token punctuation">,</span> NodeTransitionFunction f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: n is a non-null node, </span>
    <span class="token comment" spellcheck="true">// msg is an augmented message, </span>
    <span class="token comment" spellcheck="true">// r is the current value of r from the forward transition function.</span>
    <span class="token comment" spellcheck="true">// f is the forward transition function </span>
    <span class="token comment" spellcheck="true">// POST: invokes receiveMsgFromNode on node n </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsgFromNode</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Integer id<span class="token punctuation">,</span> BigInteger r<span class="token punctuation">,</span> NodeTransitionFunction f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an augmented message, </span>
    <span class="token comment" spellcheck="true">// id is the ID of the sending node, </span>
    <span class="token comment" spellcheck="true">// r is the current value of r from the forward transition function.</span>
    <span class="token comment" spellcheck="true">// f is the forward transition function </span>
    <span class="token comment" spellcheck="true">// POST: If this is the destination node, stop; </span>
    <span class="token comment" spellcheck="true">// otherwise, send the message onwards.</span>
    <span class="token comment" spellcheck="true">// Add ID of current (receiving) node to local MessageTrackCheck </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> BigInteger <span class="token function">firstRForInitiatingMessage</span><span class="token punctuation">(</span>Integer k<span class="token punctuation">,</span> BigInteger v<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: v is destination node ID, k is number of steps as a BigInteger </span>
    <span class="token comment" spellcheck="true">// POST: Uses the trapdoor function inverse, applied to destination node v with number of steps k, </span>
    <span class="token comment" spellcheck="true">// to calculate the node path; </span>
    <span class="token comment" spellcheck="true">// returns value of r that determines first step on node path </span>
<span class="token punctuation">}</span></code></pre>
<p>Note that you’ll also want to change the internals of initiateMessage(), depending on whether useBI is set to true or false in the node constructor.</p>
<h5 id="High-Distinction-Level"><a href="#High-Distinction-Level" class="headerlink" title="(High) Distinction Level"></a>(High) Distinction Level</h5><p>To achieve at least a Distinction (75−100%) for the assignment, you should do the following. You should also have completed all the Credit-level tasks.</p>
<p>There are two aspects to these advanced level tasks.</p>
<p>Corrupt Nodes The ﬁrst is implementing a simpliﬁed version of how a corrupt node might try to guess an initiator. For this, a corrupt node will assume that there is only one initiator in the network. A corrupt node forwards and receives messages just like any other node, but keeps track of which node sent it a message. Further, a corrupt node $v_{c 1}$ can ﬁnd out from another corrupt node $v_{c2}$ which node $v_p$ most recently sent $v_{c2}$ a message; that node $v_p$ could likewise be corrupt, and $v_{c1}$ could then query $v_p$ as well.</p>
<p>We will stipulate that a corrupt node $v_{c1}$ guesses another node $v_g$ to be a message initiator if it discovers that $v_g$ has transmitted messages that have reached $v_{c1}$ along two diﬀerent paths. ($v_{c1}$ does not have to be the receiver; it may have just forwarded the message.)</p>
<p>Consider an example that extends from §2.2. We have the same network with nodes 0 . . . 19, and initiator node v 0 = 1. In this example, v 0 sends a ﬁrst message with path length 2 to node v 2 = 8; the path will be 1 → 2 → 8. 0 Then it sends a second message with path length 4 to node $v_4 = 7$; the path will be 1 → 13 → 19 → 8 → 7.</p>
<p>Assume that nodes 2, 8, 13 and 19 are corrupt. Node 8 can then guess that node $v_0 = 1$ is the initiator. If the set of nodes that are corrupt were instead {2, 8, 19}, it could not be guessed.</p>
<p>Write the following methods in class Node</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCorrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Sets a node to be corrupt </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Integer <span class="token function">lastSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: If a node is not corrupt, returns -1; </span>
    <span class="token comment" spellcheck="true">// if a node is corrupt, returns ID of node that last sent it a message, </span>
    <span class="token comment" spellcheck="true">// -1 if it has not been sent any messages </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Integer <span class="token function">guessInitiator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Guesses a node to be the initiator if it can track back through corrupted nodes </span>
    <span class="token comment" spellcheck="true">// along two separate paths; </span>
    <span class="token comment" spellcheck="true">// returns this node ID, or -1 if no guess </span>
<span class="token punctuation">}</span></code></pre>
<p>Encryption In the second part of the advanced level, you’ll be working with actual encrypted messages. Specifically, we will use ElGamal encryption 11 as speciﬁed in Rass and Wigoutschnigg [2016]. As with encryption in general, this involves a public key and a private key. When an initiator node v 0 wants to send a message to a receiver node v, it will use v’s public key to encrypt the message; then only v can decrypt it, using its private key.</p>
<p>Determining whether a node is the destination or not is thus diﬀerent from the earlier levels: there is no longer an augmented message of type String where the last 3 characters give the destination. Instead, we will implement it as described in Rass and Wigoutschnigg [2016]. First, the initiator uses a hash function on the original message, and then concatenates this hash value (which for us will be 3 characters long) to form an augmented message; it then encrypts this augmented message using the receiver’s public key. It sends this encrypted message as usual.</p>
<p>Each node along the path to the receiver tries to decrypt the encrypted message with its own private key. Treating the decryption as a String, it hashes the ﬁrst n − 3 characters and compares it to the last 3 characters of the decryption. If it is the correct private key, these will match; if it is not, the decryption will look like gobbledygook rather than a valid string, and the hashes will not match.</p>
<p>There are a number of sample programs you can ﬁnd on the Internet which use the same mechanisms we will use. 12 The cryptography libraries are part of javax.crypto.Cipher; to import this, you’ll have to add some external libraries (made available in iLearn) to the project. </p>
<p>You then need to implement the following methods in class Node</p>
<p>The following are some getter methods.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Boolean <span class="token function">hasMsgEncryption</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Returns true if messages are encrypted, false otherwise </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Key <span class="token function">getPublicKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE:</span>
    <span class="token comment" spellcheck="true">// POST: Returns the node’s public key (null if hasMsgEncryption() is false) </span>
<span class="token punctuation">}</span></code></pre>
<p>Do this by right-clicking on your project in Eclipse and selecting Properties – Java Build Path – Libraries – Add External JARs.</p>
<p>The following methods are related to the new deﬁnition of augmented messages.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">basicHashFunction</span> <span class="token punctuation">(</span>String m<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: </span>
    <span class="token comment" spellcheck="true">// POST: Sums the numeric value of each character using Character.getNumericValue(), </span>
    <span class="token comment" spellcheck="true">// takes mod 100 of the total; returns as a 3-char string </span>
<span class="token punctuation">}</span></code></pre>
<p>An an example, the basic hash function when applied to string hello should return the string 097.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">addCheckToMsg</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is a message </span>
    <span class="token comment" spellcheck="true">// POST: Returns a string that concatenates the basicHashFunction of msg </span>
    <span class="token comment" spellcheck="true">// E.g. for msg="hello", returns "hello097" </span>
<span class="token punctuation">}</span></code></pre>
<p>The following methods are the heart of the message encryption process.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">encryptedMsg</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Key chosenPubKey<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is a message, chosenPubKey is a public key </span>
    <span class="token comment" spellcheck="true">// POST: Returns msg encrypted with chosenPubKey </span>
    <span class="token comment" spellcheck="true">// (null if hasMsgEncryption() is false or chosenPubKey is null) </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">decryptedMsg</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an encrypted message as a byte array </span>
    <span class="token comment" spellcheck="true">// POST: Returns msg decrypted using node’s private key </span>
    <span class="token comment" spellcheck="true">// (null if hasMsgEncryption() is false) </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> Boolean <span class="token function">isDestinationNode</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// PRE: msg is an augmented encrypted message (i.e. containing 3 check digits at the end) </span>
    <span class="token comment" spellcheck="true">// POST: Returns true if this is the destination node, false otherwise.</span>
    <span class="token comment" spellcheck="true">// Determines if this is the destination by decrypting msg, // then comparing the hashed decrypted core msg (i.e. up to the last 3 //// characters) </span>
    <span class="token comment" spellcheck="true">// against the last 3 chars of the decrypted msg </span>
<span class="token punctuation">}</span></code></pre>
<p>Note that to fully implement encrypted messages, you’d also have to deﬁne new functions sendMsgToNode() and recMsgFromNode() so that their message arguments were of type byte[] rather than String, and change the internals of several other functions. However, you don’t have to do this for the assignment. Only the above functions will be tested in the JUnit tests.</p>

        
    </section>
</article>


</div>
        <footer class="footer">
    <!-- Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a> -->
    <div class="footer-inner">
        <div class="copyright">© 2016 - 2019&nbsp;&nbsp;AssignmentDo</div>
    </div>
</footer>
    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script>
    

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
